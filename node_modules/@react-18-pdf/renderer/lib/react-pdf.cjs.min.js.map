{"version":3,"file":"react-pdf.cjs.min.js","sources":["../src/utils/propsEqual.js","../src/renderer.js","../src/index.js","../src/node/renderToFile.js","../src/node/renderToStream.js","../src/node/renderToString.js","../src/node/index.js"],"sourcesContent":["/* eslint-disable no-continue */\n\n/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\nconst propsEqual = (a, b) => {\n  const oldPropsKeys = Object.keys(a);\n  const newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < oldPropsKeys.length; i += 1) {\n    const propName = oldPropsKeys[i];\n\n    if (propName === 'render' && !a[propName] !== !b[propName]) {\n      return false;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (\n        typeof a[propName] === 'object' &&\n        typeof b[propName] === 'object' &&\n        propsEqual(a[propName], b[propName])\n      ) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (\n      propName === 'children' &&\n      (typeof a[propName] === 'string' || typeof b[propName] === 'string')\n    ) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nexport default propsEqual;\n","/* eslint-disable no-unused-vars */\n/* eslint-disable no-param-reassign */\n\nimport ReactFiberReconciler from 'react-reconciler';\nimport {\n  unstable_scheduleCallback as schedulePassiveEffects,\n  unstable_cancelCallback as cancelPassiveEffects,\n} from 'scheduler';\n\nimport propsEqual from './utils/propsEqual';\n\nconst emptyObject = {};\n\nconst createRenderer = ({ onChange = () => {} }) => {\n  return ReactFiberReconciler({\n    schedulePassiveEffects,\n\n    cancelPassiveEffects,\n\n    supportsMutation: true,\n\n    isPrimaryRenderer: false,\n\n    warnsIfNotActing: false,\n\n    appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    createInstance(type, { style, children, ...props }) {\n      return {\n        type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: [],\n      };\n    },\n\n    createTextInstance(text, rootContainerInstance) {\n      return { type: 'TEXT_INSTANCE', value: text };\n    },\n\n    finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n\n    getPublicInstance(instance) {\n      return instance;\n    },\n\n    prepareForCommit() {\n      // Noop\n    },\n\n    clearContainer() {\n      // Noop\n    },\n\n    prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n\n    resetAfterCommit: onChange,\n\n    resetTextContent(element) {\n      // Noop\n    },\n\n    getRootHostContext() {\n      return emptyObject;\n    },\n\n    getChildHostContext() {\n      return emptyObject;\n    },\n\n    shouldSetTextContent(type, props) {\n      return false;\n    },\n\n    now: Date.now,\n\n    useSyncScheduling: true,\n\n    appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        parentInstance.children.push(child);\n      }\n    },\n\n    insertBefore(parentInstance, child, beforeChild) {\n      const index = parentInstance.children?.indexOf(beforeChild);\n\n      if (index === undefined) return;\n\n      if (index !== -1 && child)\n        parentInstance.children.splice(index, 0, child);\n    },\n\n    removeChild(parentInstance, child) {\n      const index = parentInstance.children?.indexOf(child);\n\n      if (index === undefined) return;\n\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    removeChildFromContainer(parentInstance, child) {\n      const index = parentInstance.children?.indexOf(child);\n\n      if (index === undefined) return;\n\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      const { style, ...props } = newProps;\n      instance.props = props;\n      instance.style = style;\n    },\n  });\n};\n\nexport default createRenderer;\n","import BlobStream from 'blob-stream';\nimport FontStore from '@react-18-pdf/font';\nimport renderPDF from '@react-18-pdf/render';\nimport PDFDocument from '@react-18-pdf/pdfkit';\nimport layoutDocument from '@react-18-pdf/layout';\n\nimport createRenderer from './renderer';\nimport { version } from '../package.json';\n\nconst fontStore = new FontStore();\n\n// We must keep a single renderer instance, otherwise React will complain\nlet renderer;\n\n// The pdf instance acts as an event emitter for DOM usage.\n// We only want to trigger an update when PDF content changes\nconst events = {};\n\nconst pdf = initialValue => {\n  const onChange = () => {\n    const listeners = events.change?.slice() || [];\n    for (let i = 0; i < listeners.length; i += 1) listeners[i]();\n  };\n\n  const container = { type: 'ROOT', document: null };\n  renderer = renderer || createRenderer({ onChange });\n  const mountNode = renderer.createContainer(container);\n\n  const updateContainer = doc => {\n    renderer.updateContainer(doc, mountNode, null);\n  };\n\n  if (initialValue) updateContainer(initialValue);\n\n  const render = async (compress = true) => {\n    const props = container.document.props || {};\n    const { pdfVersion, language, pageLayout, pageMode } = props;\n\n    const ctx = new PDFDocument({\n      compress,\n      pdfVersion,\n      lang: language,\n      displayTitle: true,\n      autoFirstPage: false,\n      pageLayout,\n      pageMode,\n    });\n\n    const layout = await layoutDocument(container.document, fontStore);\n\n    return renderPDF(ctx, layout);\n  };\n\n  const callOnRender = (params = {}) => {\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  };\n\n  const toBlob = async () => {\n    const instance = await render();\n    const stream = instance.pipe(BlobStream());\n\n    return new Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        try {\n          const blob = stream.toBlob('application/pdf');\n          callOnRender({ blob });\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      stream.on('error', reject);\n    });\n  };\n\n  const toBuffer = async () => {\n    callOnRender();\n    return render();\n  };\n\n  const toString = async () => {\n    let result = '';\n    const instance = await render(false); // For some reason, when rendering to string if compress=true the document is blank\n\n    return new Promise((resolve, reject) => {\n      try {\n        instance.on('data', buffer => {\n          result += buffer;\n        });\n\n        instance.on('end', () => {\n          callOnRender();\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  };\n\n  const on = (event, listener) => {\n    if (!events[event]) events[event] = [];\n    events[event].push(listener);\n  };\n\n  const removeListener = (event, listener) => {\n    if (!events[event]) return;\n    const idx = events[event].indexOf(listener);\n    if (idx > -1) events[event].splice(idx, 1);\n  };\n\n  return {\n    on,\n    container,\n    toBlob,\n    toBuffer,\n    toString,\n    removeListener,\n    updateContainer,\n  };\n};\n\nconst Font = fontStore;\n\nconst StyleSheet = {\n  create: s => s,\n};\n\nexport { version, Font, StyleSheet, pdf, createRenderer };\n","import fs from 'fs';\n\nimport { pdf } from '../index';\n\nexport const renderToFile = async (element, filePath, callback) => {\n  const instance = pdf(element);\n  const output = await instance.toBuffer();\n  const stream = fs.createWriteStream(filePath);\n\n  output.pipe(stream);\n\n  return new Promise((resolve, reject) => {\n    stream.on('finish', () => {\n      if (callback) callback(output, filePath);\n      resolve(output);\n    });\n    stream.on('error', reject);\n  });\n};\n\nexport default renderToFile;\n","import { pdf } from '../index';\n\nexport const renderToStream = async element => {\n  const instance = pdf(element);\n  const buffer = await instance.toBuffer();\n  return buffer;\n};\n\nexport default renderToStream;\n","import { pdf } from '../index';\n\nexport const renderToString = element => {\n  const instance = pdf(element);\n  return instance.toString();\n};\n\nexport default renderToString;\n","import * as primitives from '@react-18-pdf/primitives';\n\nimport renderToFile from './renderToFile';\nimport renderToStream from './renderToStream';\nimport renderToString from './renderToString';\nimport { pdf, version, Font, StyleSheet } from '../index';\n\nconst throwEnvironmentError = name => {\n  throw new Error(\n    `${name} is a web specific API. You're either using this component on Node, or your bundler is not loading react-pdf from the appropriate web build.`,\n  );\n};\n\nexport const usePDF = () => {\n  throwEnvironmentError('usePDF');\n};\n\nexport const PDFViewer = () => {\n  throwEnvironmentError('PDFViewer');\n};\n\nexport const PDFDownloadLink = () => {\n  throwEnvironmentError('PDFDownloadLink');\n};\n\nexport const BlobProvider = () => {\n  throwEnvironmentError('BlobProvider');\n};\n\nexport const render = renderToFile;\n\nexport * from '../index';\n\nexport * from './renderToFile';\n\nexport * from './renderToStream';\n\nexport * from './renderToString';\n\nexport * from '@react-18-pdf/primitives';\n\nexport default {\n  pdf,\n  Font,\n  version,\n  StyleSheet,\n  usePDF,\n  PDFViewer,\n  BlobProvider,\n  PDFDownloadLink,\n  renderToStream,\n  renderToString,\n  renderToFile,\n  render,\n  ...primitives,\n};\n"],"names":["propsEqual","a","b","oldPropsKeys","Object","keys","newPropsKeys","length","i","propName","emptyObject","createRenderer","onChange","ReactFiberReconciler","schedulePassiveEffects","unstable_scheduleCallback","cancelPassiveEffects","unstable_cancelCallback","supportsMutation","isPrimaryRenderer","warnsIfNotActing","appendInitialChild","parentInstance","child","children","push","createInstance","type","style","props","box","createTextInstance","text","rootContainerInstance","value","finalizeInitialChildren","element","getPublicInstance","instance","prepareForCommit","clearContainer","prepareUpdate","oldProps","newProps","resetAfterCommit","resetTextContent","getRootHostContext","getChildHostContext","shouldSetTextContent","now","Date","useSyncScheduling","appendChild","appendChildToContainer","document","insertBefore","beforeChild","_parentInstance$child","index","indexOf","undefined","splice","removeChild","_parentInstance$child2","removeChildFromContainer","_parentInstance$child3","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayload","fontStore","FontStore","renderer","events","pdf","initialValue","container","_events$change","listeners","change","slice","mountNode","createContainer","updateContainer","doc","render","async","compress","pdfVersion","language","pageLayout","pageMode","ctx","PDFDocument","lang","displayTitle","autoFirstPage","layout","layoutDocument","renderPDF","callOnRender","params","onRender","on","event","listener","toBlob","stream","pipe","BlobStream","Promise","resolve","reject","blob","error","toBuffer","toString","result","buffer","removeListener","idx","Font","StyleSheet","create","s","renderToFile","filePath","callback","output","fs","createWriteStream","renderToStream","renderToString","throwEnvironmentError","name","Error","usePDF","PDFViewer","PDFDownloadLink","BlobProvider","version","primitives"],"mappings":"suBAUA,MAAMA,EAAa,CAACC,EAAGC,KACrB,MAAMC,EAAeC,OAAOC,KAAKJ,GAC3BK,EAAeF,OAAOC,KAAKH,GAEjC,GAAIC,EAAaI,SAAWD,EAAaC,OACvC,OAAO,EAGT,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAaI,OAAQC,GAAK,EAAG,CAC/C,MAAMC,EAAWN,EAAaK,GAE9B,GAAiB,WAAbC,IAA0BR,EAAEQ,KAAeP,EAAEO,GAC/C,OAAO,EAGT,GAAiB,aAAbA,GAA2BR,EAAEQ,KAAcP,EAAEO,GAAW,CAC1D,GACyB,iBAAhBR,EAAEQ,IACc,iBAAhBP,EAAEO,IACTT,EAAWC,EAAEQ,GAAWP,EAAEO,IAE1B,SAGF,OAAO,EAGT,GACe,aAAbA,IACwB,iBAAhBR,EAAEQ,IAAiD,iBAAhBP,EAAEO,IAE7C,OAAOR,EAAEQ,KAAcP,EAAEO,GAI7B,OAAO,GClCHC,EAAc,GAEdC,EAAiB,EAAGC,WAAW,YAC5BC,UAAqB,wBAC1BC,EAD0BC,+CAG1BC,EAH0BC,wBAK1BC,kBAAkB,EAElBC,mBAAmB,EAEnBC,kBAAkB,EAElBC,mBAAmBC,EAAgBC,GACjCD,EAAeE,SAASC,KAAKF,IAG/BG,eAAc,CAACC,GAAMC,MAAEA,EAAFJ,SAASA,KAAaK,MAClC,CACLF,OACAG,IAAK,GACLF,MAAOA,GAAS,GAChBC,MAAOA,GAAS,GAChBL,SAAU,KAIdO,mBAAkB,CAACC,EAAMC,KAChB,CAAEN,KAAM,gBAAiBO,MAAOF,IAGzCG,wBAAuB,CAACC,EAAST,EAAME,KAC9B,EAGTQ,kBAAkBC,GACTA,EAGTC,qBAIAC,mBAIAC,cAAa,CAACL,EAAST,EAAMe,EAAUC,KAC7B3C,EAAW0C,EAAUC,GAG/BC,iBAAkBhC,EAElBiC,iBAAiBT,KAIjBU,mBAAkB,IACTpC,EAGTqC,oBAAmB,IACVrC,EAGTsC,qBAAoB,CAACrB,EAAME,KAClB,EAGToB,IAAKC,KAAKD,IAEVE,mBAAmB,EAEnBC,YAAY9B,EAAgBC,GAC1BD,EAAeE,SAASC,KAAKF,IAG/B8B,uBAAuB/B,EAAgBC,GACT,SAAxBD,EAAeK,KACjBL,EAAegC,SAAW/B,EAE1BD,EAAeE,SAASC,KAAKF,IAIjCgC,aAAajC,EAAgBC,EAAOiC,GAAa,IAAAC,EAC/C,MAAMC,UAAQpC,EAAAA,EAAeE,6BAAfiC,EAAyBE,QAAQH,QAEjCI,IAAVF,IAEW,IAAXA,GAAgBnC,GAClBD,EAAeE,SAASqC,OAAOH,EAAO,EAAGnC,IAG7CuC,YAAYxC,EAAgBC,GAAO,IAAAwC,EACjC,MAAML,UAAQpC,EAAAA,EAAeE,6BAAfuC,EAAyBJ,QAAQpC,QAEjCqC,IAAVF,IAEW,IAAXA,GAAcpC,EAAeE,SAASqC,OAAOH,EAAO,IAG1DM,yBAAyB1C,EAAgBC,GAAO,IAAA0C,EAC9C,MAAMP,UAAQpC,EAAAA,EAAeE,6BAAfyC,EAAyBN,QAAQpC,QAEjCqC,IAAVF,IAEW,IAAXA,GAAcpC,EAAeE,SAASqC,OAAOH,EAAO,IAG1DQ,iBAAiBC,EAAcC,EAASC,GACtCF,EAAajC,MAAQmC,GAGvBC,aAAahC,EAAUiC,EAAe5C,EAAMe,EAAUC,GACpD,MAAMf,MAAEA,KAAUC,GAAUc,EAC5BL,EAAST,MAAQA,EACjBS,EAASV,MAAQA,KCxHvB,MAAM4C,EAAY,IAAIC,EAAAA,QAGtB,IAAIC,EAIJ,MAAMC,EAAS,GAETC,EAAMC,IACV,MAKMC,EAAY,CAAEnD,KAAM,OAAQ2B,SAAU,MAC5CoB,EAAWA,GAAY/D,EAAe,CAAEC,SANvB,KAAM,IAAAmE,EACrB,MAAMC,GAAY,QAAAL,EAAAA,EAAOM,cAAP,IAAAF,OAAA,EAAAA,EAAeG,UAAW,GAC5C,IAAK,IAAI1E,EAAI,EAAGA,EAAIwE,EAAUzE,OAAQC,GAAK,EAAGwE,EAAUxE,QAK1D,MAAM2E,EAAYT,EAASU,gBAAgBN,GAErCO,EAAkBC,IACtBZ,EAASW,gBAAgBC,EAAKH,EAAW,OAGvCN,GAAcQ,EAAgBR,GAElC,MAAMU,EAASC,MAAOC,GAAW,KAC/B,MAAM5D,EAAQiD,EAAUxB,SAASzB,OAAS,IACpC6D,WAAEA,EAAFC,SAAcA,EAAdC,WAAwBA,EAAxBC,SAAoCA,GAAahE,EAEjDiE,EAAM,IAAIC,UAAY,CAC1BN,WACAC,aACAM,KAAML,EACNM,cAAc,EACdC,eAAe,EACfN,aACAC,aAGIM,QAAeC,EAAc,QAACtB,EAAUxB,SAAUkB,GAExD,OAAO6B,EAAS,QAACP,EAAKK,IAGlBG,EAAe,CAACC,EAAS,MACzBzB,EAAUxB,SAASzB,MAAM2E,UAC3B1B,EAAUxB,SAASzB,MAAM2E,SAASD,IA2DtC,MAAO,CACLE,GAZS,CAACC,EAAOC,KACZhC,EAAO+B,KAAQ/B,EAAO+B,GAAS,IACpC/B,EAAO+B,GAAOjF,KAAKkF,IAWnB7B,YACA8B,OA1DapB,UACb,MACMqB,SADiBtB,KACCuB,KAAKC,EAAAA,WAE7B,OAAO,IAAIC,SAAQ,CAACC,EAASC,KAC3BL,EAAOJ,GAAG,UAAU,KAClB,IACE,MAAMU,EAAON,EAAOD,OAAO,mBAC3BN,EAAa,CAAEa,SACfF,EAAQE,GACR,MAAOC,GACPF,EAAOE,OAIXP,EAAOJ,GAAG,QAASS,OA4CrBG,SAxCe7B,UACfc,IACOf,KAuCP+B,SApCe9B,UACf,IAAI+B,EAAS,GACb,MAAMjF,QAAiBiD,GAAO,GAE9B,OAAO,IAAIyB,SAAQ,CAACC,EAASC,KAC3B,IACE5E,EAASmE,GAAG,QAAQe,IAClBD,GAAUC,KAGZlF,EAASmE,GAAG,OAAO,KACjBH,IACAW,EAAQM,MAEV,MAAOH,GACPF,EAAOE,QAsBXK,eAZqB,CAACf,EAAOC,KAC7B,IAAKhC,EAAO+B,GAAQ,OACpB,MAAMgB,EAAM/C,EAAO+B,GAAO/C,QAAQgD,GAC9Be,GAAO,GAAG/C,EAAO+B,GAAO7C,OAAO6D,EAAK,IAUxCrC,oBAIEsC,EAAOnD,EAEPoD,EAAa,CACjBC,OAAQC,GAAKA,GC5HFC,EAAevC,MAAOpD,EAAS4F,EAAUC,KACpD,MAAM3F,EAAWsC,EAAIxC,GACf8F,QAAe5F,EAAS+E,WACxBR,EAASsB,EAAAA,QAAGC,kBAAkBJ,GAIpC,OAFAE,EAAOpB,KAAKD,GAEL,IAAIG,SAAQ,CAACC,EAASC,KAC3BL,EAAOJ,GAAG,UAAU,KACdwB,GAAUA,EAASC,EAAQF,GAC/Bf,EAAQiB,MAEVrB,EAAOJ,GAAG,QAASS,OCdVmB,EAAiB7C,UAC5B,MAAMlD,EAAWsC,EAAIxC,GAErB,aADqBE,EAAS+E,YCFnBiB,EAAiBlG,GACXwC,EAAIxC,GACLkF,WCGZiB,EAAwBC,IAC5B,MAAM,IAAIC,MACP,GAAED,kJAIME,EAAS,KACpBH,EAAsB,WAGXI,EAAY,KACvBJ,EAAsB,cAGXK,EAAkB,KAC7BL,EAAsB,oBAGXM,EAAe,KAC1BN,EAAsB,iBAGXhD,EAASwC,EAYtB,IAAerE,EAAA,CACbkB,MACA+C,OACAmB,gBACAlB,aACAc,SACAC,YACAE,eACAD,kBACAP,iBACAC,iBACAP,eACAxC,YACGwD"}